/*
 * TIMER2_prog.c
 *
 *  Created on: ??þ/??þ/????
 *      Author: AHMED ADEL
 */
#include "std_types.h"
#include "TIMER2_int.h"
#include "utils.h"

#define TIMSK  *((volatile u8*)0x59)
#define SREG   *((volatile u8*)0x5F)
#define TCCR2  *((volatile u8*)0x45)
#define TCNT2  *((volatile u8*)0x44)
#define OCR2   *((volatile u8*)0x43)
#define ASSR   *((volatile u8*)0x42)
#define TIFR   *((volatile u8*)0x58)
#define SFIOR  *((volatile u8*)0x50)

void TIMER2_vidIntialize(void)
{

#if TIMER2_MODE == NORMAL_TIMER2
	RESETBIT(TCCR2,6);
	RESETBIT(TCCR2,3);
	#if OC2_STATE == DISCONNECTED_OC2
		RESETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#elif OC0_STATE == CLEAR_OC2
		RESETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC0_STATE == SET_OC2
		SETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC0_STATE == TOGGLE_OC2
		SETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#endif
#elif TIMER2_MODE == CTC_TIMER2
	RESETBIT(TCCR2,6);
	SETBIT(TCCR2,3);
	#if OC2_STATE == DISCONNECTED_OC2
		RESETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#elif OC2_STATE == CLEAR_OC2
		RESETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC2_STATE == SET_OC2
		SETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC2_STATE == TOGGLE_OC2
		SETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#endif
#elif TIMER2_MODE == FAST_PWM_TIMER2
	SETBIT(TCCR2,6);
	SETBIT(TCCR2,3);
	RESETBIT(TCCR2,7);
	#if OC2_STATE == DISCONNECTED_OC2
		RESETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#elif OC2_STATE == CLEAR_OC2
		RESETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC2_STATE == SET_OC2
		SETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#endif
#elif TIMER2_MODE == PHASE_CORRECT_PWM_TIMER2
	SETBIT(TCCR2,6);
	RESETBIT(TCCR2,3);
	RESETBIT(TCCR2,7);
#if OC2_STATE == DISCONNECTED_OC2
		RESETBIT(TCCR2,4);
		RESETBIT(TCCR2,5);
	#elif OC2_STATE == CLEAR_OC2
		RESETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#elif OC2_STATE == SET_OC2
		SETBIT(TCCR2,4);
		SETBIT(TCCR2,5);
	#endif
#endif

#if TIMER2_OVERFLOW_INTERRUPT_STATE == TIMER2_OVERFLOW_INTERRUPT_ENABLE
		SETBIT(TIMSK,6); // enable interrupt for over flow
#elif TIMER2_OVERFLOW_INTERRUPT_STATE == TIMER2_OVERFLOW_INTERRUPT_DISABLE
		RESETBIT(TIMSK,6);
#endif

#if TIMER2_COMP_MATCH_INTERRUPT_STATE == TIMER2_COMP_MATCH_INTERRUPT_ENABLE
		SETBIT(TIMSK,7); // enable interrupt for compare match
#elif TIMER2_COMP_MATCH_INTERRUPT_STATE == TIMER2_COMP_MATCH_INTERRUPT_DISABLE
		RESETBIT(TIMSK,7);
#endif


/* pre-scaler */
#if TIMER2_PRESCALLER == TIMER2_PRESCALER_0
		RESETBIT(TCCR2,2);
		RESETBIT(TCCR2,1);
		RESETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_1
		RESETBIT(TCCR2,2);
		RESETBIT(TCCR2,1);
		SETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_8
		RESETBIT(TCCR2,2);
		SETBIT(TCCR2,1);
		RESETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_32
		RESETBIT(TCCR2,2);
		SETBIT(TCCR2,1);
		SETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_64
		SETBIT(TCCR2,2);
		RESETBIT(TCCR2,1);
		RESETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_128
		SETBIT(TCCR2,2);
		RESETBIT(TCCR2,1);
		SETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_256
		SETBIT(TCCR2,2);
		SETBIT(TCCR2,1);
		RESETBIT(TCCR2,0);
#elif TIMER2_PRESCALLER == TIMER2_PRESCALER_1024
		SETBIT(TCCR2,2);
		SETBIT(TCCR2,1);
		SETBIT(TCCR2,0);
#endif


// enable global interrupts
SETBIT(SREG,7);

	return;
}

void TIMER2_vidSetPreloadValue(u8 u8PreloadRegCPY)
{
	TCNT2 = u8PreloadRegCPY;
	return;
}

void TIMER2_vidSetCompareMatchValue(u8 u8CompareMacthCPY)
{
	OCR2=u8CompareMacthCPY;
	return;
}



